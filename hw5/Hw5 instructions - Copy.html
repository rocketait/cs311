<div class="vtbegenerated"><span class="fnt0">Assignment 5 is due at <b>5pm Monday, November 25</b>. It is worth 25 points.</span><h2 id="anonymous_element_7">Procedures</h2><p>This is a <b>group assignment</b>. Please work in a group of 2 or 3. Each group only needs to turn in a single copy of the assignment. Under normal circumstances, each will receive the same grade on the assignment.</p><p><b>Submit your answers on Blackboard.</b></p><ul><li>Your answers should consist of two files: <code>slist.h</code>, from Exercise A, and <code>slstack.h</code>, from Exercise B.&nbsp;</li><li>Be sure to include <b>the names of all group members</b> in your comments.</li></ul><p><b>Note: Restrictions on extra public members are lifted, for this assignment. You may include public members in your classes, other than those specifically mentioned below. You may also write additional publicly available global functions.&nbsp;</b></p><h2 id="anonymous_element_8">Exercises (25 pts total)</h2><h3 id="anonymous_element_9">Exercise A — “Minimalist” Linked List Class Template</h3><h4 id="anonymous_element_10">Purpose</h4><p>In this exercise, you will write a Linked List. This will not be a full-featured package. It has those features required for testing, but its primary purpose is to be the basis for Exercise B.</p><p>You will also write a function to reverse your Linked List.</p><h4 id="anonymous_element_11">Instructions</h4><p>Implement a C++ class template that manages a Linked List. The type of item in the list should be specified by the client. Be sure to follow the coding standards. <b>All standards apply</b>, with the exception noted above concerning extra public functions.</p><ul><li>Call your class template “<code>SList</code>”, so that, for example, an <code>SList</code> of <code>double</code>s would be declared as a <code>SList&lt;double&gt;</code>.</li><li>Implement your class template in file <code>slist.h</code>. Since this is a template, there should be no associated source file.</li><li><b>Implementation.</b><ul><li>The data must be stored in an actual Linked List (singly or doubly linked).</li><li>Linked List nodes must be separately allocated (in particular, do not store them in an array).</li></ul>You may decide other implementation issues however you want, within the constraints of the coding standards, and the rest of these requirements.</li><li><b>Interface.</b> Class <code>SList</code> must include at least the following public member functions:<ul><li>Default ctor. Creates a Linked List of size zero.</li><li>Copy ctor. Copies a Linked List, as usual. The copy must contain completely separate data. (That is, do a deep copy.)</li><li>Copy assignment operator. Copies a Linked List, as usual. The copy must contain completely separate data.</li><li>Dctor. Does all necessary deallocation, destruction, and other necessary clean-up.</li><li>Function <code>size</code>. Returns the size of the Linked List. No parameters.</li><li>Function <code>read</code>. Given two input iterators (<i>see Notes on Iterators, below</i>) that specify a range, in the usual manner. Returns nothing. The value type of the iterators is assumed to be the same as that of the Linked List. When the function is done, the items in the range are contained in the Linked List, in the same order. Whatever data the Linked List previously contained have been discarded.</li><li>Function <code>wr</code><code>ite</code>. Given a single output iterator (<i>see Notes on Iterators, below</i>). Returns nothing. Writes the items in the Linked List to the iterator, in order. Assumes that the iterator references the beginning of a range with enough space.</li><li>Function <code>reverse</code>. No parameters. Returns nothing. After this function is executed, the Linked List contains the same data items, but in the reverse order.<ul><li>Function <code>reverse</code> must <i>not</i> do any value-type operations; only manipulate pointers.</li><li>Function <code>reverse</code> must use only <i>constant</i> additional storage. In particular, function <code>reverse</code> must not be recursive.</li></ul></li></ul><b>Other public member functions, member types, and data members may be added to the interface as you see fit.</b></li><li>You may <i>not</i> use any C++ Standard Library <b>classes</b> in your implementation. (You may use simple types, like <code>std::size_t</code>.)</li><li>You may <i>not</i> use any C++ Standard Library <b>functions</b> in your implementation, except for <code>std::swap</code> and <code>std::iter_swap</code>.</li><li>All of the functions specified above should have the highest reasonable levels of efficiency and exception safety.</li><li>All of the functions specified above must be exception-neutral; that is, exceptions thrown by value-type operations must propagate unchanged to the caller.</li><li>You may not forbid any member function of the value type from throwing, except for the destructor.</li></ul><h3 id="anonymous_element_12">Exercise B — Stack Template</h3><h4 id="anonymous_element_13">Purpose</h4><p>In this exercise, you will write a Stack that uses the Linked List from Exercise A to hold its data.</p><h4 id="anonymous_element_14">Instructions</h4><p>Implement a C++ class template that manages a Stack. The type of item in the Stack should be specified by the client. Be sure to follow the coding standards. <b>All standards apply</b>, with the exception noted above concerning extra public functions.</p><ul><li>Call your class template “<code>SLStack</code>”, so that, for example, an <code>SLStack</code> of <code>double</code>s would be declared as a <code>SLStack&lt;double&gt;</code>.</li><li>Implement your class template in file <code>slstack.h</code>. Since this is a template, there should be no associated source file.</li><li>The data in your Stack should all be contained in a single data member, which is an <code>SList</code>. Do not duplicate the code for <code>SList</code>; instead, do “<code>#include "slist.h"</code>” in the header for the Stack.</li><li><b>Interface.</b> Class <code>SLStack</code> must include at least the following public member functions:<ul><li>Default ctor. Creates an empty Stack.</li><li>Copy ctor. As usual.</li><li>Copy assignment. As usual.</li><li>Dctor. As usual.</li><li>Function <code>empty</code>. No parameters. Returns a <code>bool</code> indicating whether the Stack is empty.</li><li>Function <code>top</code>. No parameters. Returns a reference to the top item of the Stack. This should allow modification of the top item, for a non-const Stack, but not for a const Stack.</li><li>Function <code>push</code>. Given a data item. Returns nothing. Pushes the given value.</li><li>Function <code>pop</code> No parameters. Returns nothing. Pops the top item, if any.<ul><li>How this function behaves when the Stack is empty, is up to you, but this must be documented.</li></ul></li></ul><b>Other public member functions, member types, and data members may be added to the interface as you see fit.</b></li><li>You may <i>not</i> use any C++ Standard Library <b>classes</b> in your implementation. (You may use simple types, like <code>std::size_t</code>.)</li><li>You may <i>not</i> use any C++ Standard Library <b>functions</b> in your implementation, except for <code>std::swap</code> and <code>std::iter_swap</code>.</li><li>All member functions should have the highest reasonable levels of efficiency and exception safety.</li><li>All member functions must be exception-neutral; that is, exceptions thrown by value-type operations must propagate unchanged to the caller.</li><li>You may not forbid any member function of the value type from throwing, except for the destructor.</li></ul><h3 id="anonymous_element_15">Notes</h3><h4 id="anonymous_element_16">Sample code:</h4><p>You might wish to start with our linked list sample code from class:&nbsp;<a alt="" target="_blank" href="https://classes.uaf.edu/bbcswebdav/pid-2062926-dt-content-rid-5048203_1/xid-5048203_1">linked_list.cpp</a>.</p><h4 id="anonymous_element_17">About Iterators</h4><p>Some facts:</p><ul><li>An <b>output iterator</b> is one that can only be written to, using “<code>*iter++</code>”.</li><li>Similarly, an <b>input iterator</b> is one that can only be read from, using “<code>*iter++</code>”. You can also compare equality or inequality of two input iterators.</li><li>Always pass iterators by value.</li></ul><p>Thus, <code>SList::read</code> and <code>SList::write</code> will look something like this (with the actual function definition being outside the class, of course.)</p><blockquote><pre>  template &lt;typename T&gt;<br>    class SList {<br>   <br>    [ <i> A LOT IS LEFT OUT HERE</i> ]<br>   <br>    public:<br>        template &lt;typename InputIterator&gt;<br>        void read(InputIterator first, InputIterator last)<br>        {<br>            [ <i> CLEAR THE ITEMS IN THE LIST HERE</i> ]<br>            while (first != last)<br>            {<br>                value_type val = *first++;<br>                [ <i> PUT val INTO THE LIST HERE</i> ]<br>            }<br>        }<br>   <br>        template &lt;typename OutputIterator&gt;<br>        void write(OutputIterator dest) const<br>        {<br>            for ( [ <i> ???</i> ] ) // ITERATE THROUGH LINKED LIST, SOMEHOW)<br>            {<br>                value_type val;<br>                [ <i> HERE, PUT NEXT LIST ITEM INTO VAL</i> ]<br>                *dest++ = val;<br>            }<br>        }<br>    }; </pre></blockquote><h4 id="anonymous_element_18">About Friendship</h4><p>Dealing with templates that are friends can be (syntactically) difficult. Compilers even had trouble with this issue until just a couple of years ago. If you have trouble with compiler errors due to things being private, etc., you might wish to make everything public until you get things working, then ask me for help. (Or you can follow the advice in the <a href="http://www.parashift.com/c++-faq-lite/templates.html#faq-35.16">C++ FAQ</a>, which is pretty straightforward.)</p><h4 id="anonymous_element_19">Test Program</h4><p>I have written a single test program for both exercises: <a alt="" target="_blank" href="https://classes.uaf.edu/bbcswebdav/pid-2062926-dt-content-rid-5048204_1/xid-5048204_1">da6_test.cpp</a>. (Pardon the "6", this used to be Assignment 6.) If you compile and run your package with this program (unmodified!), then it will test whether your code works properly.</p><p>Do not turn in <code>da6_test.cpp</code>.</p><p>Because of the single test program, the code for <i>both</i> exercises must at least exist, and must compile with the test program. Code that does not compile at all will not be graded.</p><h4 id="anonymous_element_20">Other Thoughts</h4><p>If you do a good job on Exercise A (the Linked List), then Exercise B (the Stack) should be very easy. In particular, if the Linked List knows how to initialize, copy, and destroy itself properly, then the compiler-written default ctor and Big-Three functions should be fine, for the Stack class. That leaves <code>empty</code>, <code>top</code>, <code>push</code>, and <code>pop</code>, none of which is likely to be very difficult.</p><p>For the Linked List class, remember the swap trick for writing copy assignment. Also remember that it is probably easier to put necessary functionality into class <code>SList</code> than to have the Stack manage the internal details of the Linked List.</p></div>